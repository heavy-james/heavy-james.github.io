---
layout: post
title:  面向对象的设计原则
description: 面向对象的设计原则及原则间联系
category: blog
---

从纯函数编程到面向对象编程的进展，就是把软件行为，用对象的行为去模拟理解。面向对象的优点有易理解，易复用，易扩展，易维护等等。

面向对象的设计目标，就是使软件系统可扩展，可复用，可维护等。那么为了达到这些目的，我们总结了一些规律，符合这些规律的设计，将更有可能达到这些目标，否则相反。我们称这些规律为设计原则。

## 开闭原则
* ####  软件系统应该对扩展开放，对修改关闭。
* #### 软件系统应该在尽量不修改原有代码的情况下，进行拓展。

开闭原则相当于是设计原则的总则，是设计原则目标的一个复述，可以说满足开闭原则的系统，就具有可复用、可扩展、可维护的特点，是一个实现了很好面向对象设计的系统。

注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。 


## 单一职责原则
一个对象是一个类的具体实例，一个类是具有共同特征的一类事物的抽象，那么这个共同特征的范畴符合确定，直接影响一个面向对象设计好坏。

总体上来说，一个抽象应该只描述最简单的事物。这样，只有它所描述的事物发生改变时，它才需要改变。它的严谨表述为：

* #### 一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

单一职责原则，是开闭原则中闭则的实施。

## 依赖倒置原则
* #### 软件应当针对接口编程，而不是针对实现编程。
 
依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。

在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，是通过对开闭原则中开原则的实施，来支持闭原则。

在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。

常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。


## 接口隔离原则
* #### 使用该接口的客户端仅需知道与之相关的方法即可。
这个是涉及到前端、后台交互时的接口理解方式，应该不属于面向对象编程讨论范围，但是也有参考意义。 


* #### 每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。
依赖倒置原则指出对接口编程使软件系统实施了开原则，支持了闭原则。依赖倒置原则引入了软件抽象层，那么，，接口隔离原则是单一职责原则，在抽象层的应用。
 
## 里氏代换原则
* #### 在软件系统中，所有父类对象，可以被其子类透明地替换，而软件行为不会产生差异。

里氏代换原则是对依赖倒置的一个规范化，它通过敦促类的继承和实现，严格遵循接口设计，辅之以依赖倒置原则，可以很好地支持开闭原则。

## 合成复用原则
* #### 复用时要尽量使用组合/聚合关系（关联关系），少用继承。

 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。"Is-A"是严格的分类学意义上的定义，意思是一个类是另一个类的"一种"；而"Has-A"则不同，它表示某一个角色具有某一项责任。
 
 合成复用原则是针对软件复用方式的一个原则，前面的几个原则是针对软件的扩展和维护的。当然，复用性好的软件系统，一定程度上也具有较好的扩展性和可维护性。
 
 软件的复用有两种，继承和组合(聚合)，继承是白箱复用，父类的实现暴露给子类，父类的改动必然会引起子类的改动，并且继承属于静态复用，灵活性较差。组合是黑箱复用，使用类对封装类的实现细节并不了解，并且可以在运行时根据实际需要，动态地引用与该对象类型相同的其他对象。
 
 ## 迪米特法则
 * #### 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。
 
 * #### 简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。
 
 * #### 不要和“陌生人”说话、只与你的直接朋友通信等
 
 * #### 类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。
 
迪米特法也是一个复用性法则，是合成复用模式的一个规范化。合成复用原则促使软件系统的复用方式多为组合、聚合，迪米特法则则促使组合和聚合复用中，类和类之间、模块和模块之间的耦合性降至最低，它指导软件设计创建松耦合的系统，类之间的耦合性越低，说明它的内聚程度越高，复用性越好。

类的直接朋友定义是：
1. 【内部】对象自身，this。
2. 【内部】对象的成员(如果成员是集合，也包括集合中的元素)。
3. 【内部】对象创建的对象。
4. 【外部】以方法参数传入的对象。
 
# 总结

设计模式直接是相互补充的，最终的目的是是软件系统易复用，易扩展，易维护。它的总则是软件应当对扩展开放，对修改关闭。开则的支撑是依赖倒置原则，引入软件抽象层，并且针对抽象层编程。它的闭则是单一职责原则，一个类只负责一个功能。单一职责应用到抽象层，就有了接口隔离原则。依赖倒置也引出了复用模式原则，因为有了抽象层，就需要实现和复用实现，，尽量使用灵活的组合方式，而减少使用静态的继承模式，即合成复用原则。单一职责原则和合成复用原则是相互佐证的。如果要是用组合复用，则应遵守迪米特法则，创建松耦合的软件结构。如果要使用继承复用，则要遵循里氏代换原则，子类的和父类的关系应该是严格的IS-A关系，在接口设计的时候，要既完整又不冗余，子类可以无差别替代父类。

图示：
![](https://heavy-james.github.io/images/common/oop-princeple-ralation.png)

参考文档：
[gitbook 设计模式讲解](https://www.gitbook.com/book/quanke/design-pattern-java/details)
